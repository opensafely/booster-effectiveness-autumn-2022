######################################

# This script:

######################################

# Preliminaries ----

## Import libraries ----
library(tidyverse)
library(lubridate)
library(glue)
library(here)

## import local functions and parameters ---

source(here("analysis", "design.R"))

source(here("lib", "functions", "utility.R"))

source(here("analysis", "process", "process_functions.R"))

## import command-line arguments ----

args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 0) {
  # use for interactive testing
  # stage <- "treated"
  stage <- "controlpotential"
  # stage <- "controlactual"
  # stage <- "controlfinal"
  matching_round <- as.integer("1")
} else {
  stage <- args[[1]]
  if (stage %in% "treated") {
    if (length(args) > 1) 
      stop("No additional args to be specified when `stage=\"treated\"")
  } else {
    if (length(args) == 1) {
      stop("`matching_round` must be specified when `stage=\"controlpotential\"` or \"controlactual\"")
    }
    matching_round <- as.integer(args[[2]]) # NULL if treated    
  } 
} 

# ## create output directories and define parameters ----
if (stage == "treated") {
  path_stem <- here("output", "treated")
  fs::dir_create(file.path(path_stem, "eligible"))
  fs::dir_create(file.path(path_stem, "process"))
  fs::dir_create(file.path(path_stem, "flowchart"))
  studydef_path <- file.path(path_stem, "extract", "input_treated.feather")
  custom_path <- file.path(path_stem, "dummydata", "dummydata_treated.feather")
} else if (stage %in% c("controlpotential", "controlactual")) {
  path_stem <- ghere("output", "matchround{matching_round}", stage)
  fs::dir_create(file.path(path_stem, "eligible"))
  fs::dir_create(file.path(path_stem, "process"))
  studydef_path <- file.path(path_stem, "extract", glue("input_{stage}.feather"))
  custom_path <- here("output", "matchround1", "controlpotential", "dummydata", "dummydata_controlpotential.feather")
  matching_round_date <- study_dates$control_extract[matching_round]
} 

# import data ----
# read data generated by study def
data_studydef <- arrow::read_feather(studydef_path) %>%
  process_input()

if(Sys.getenv("OPENSAFELY_BACKEND") %in% c("", "expectations")) {
  
  data_dummy <- arrow::read_feather(custom_path) 
  
  # check dummydata
  source(here("analysis", "dummydata", "dummydata_check.R"))
  dummydata_check(
    dummydata_studydef= data_studydef,
    dummydata_custom = data_dummy
  )
  
  data_extract <- data_dummy
  rm(data_dummy)
  
} else {
  
  data_extract <- data_studydef
  rm(data_studydef)
  
}

# extra processing when stage = actual
if (stage == "controlactual") {
  
  ## trial info for potential matches in round X
  data_potential_matchstatus <- 
    read_rds(ghere("output", "matchround{matching_round}", "potential", "data_potential_matchstatus.rds")) %>% 
    filter(matched==1L)
  
  # if using dummy data
  if(Sys.getenv("OPENSAFELY_BACKEND") %in% c("", "expectations")) {
    
    # set seed so that dummy data results are reproducible
    set.seed(10)
    
    # reuse previous extraction for dummy run, dummy_control_potential1.feather
    data_extract <- data_extract %>%
      filter(patient_id %in% data_potential_matchstatus[(data_potential_matchstatus$treated==0L),]$patient_id) %>%
      # trial_date and match_id are not included in the dummy data so join them on here
      # they're joined in the study def using `with_values_from_file`
      left_join(
        data_potential_matchstatus %>% 
          filter(treated==0L) %>%
          select(patient_id, trial_date, match_id),
        by="patient_id"
      ) %>%
      # change a few variables to simulate new index dates
      mutate(
        region = if_else(runif(n())<0.05, sample(x=unique(region), size=n(), replace=TRUE), region)
      )
    
  }
  
  # add certain matching variables
  # add: treated 
  data_extract <- data_extract %>%
    mutate(treated=0L) %>%
    # add: trial_time, matched, control, controlistreated_date to data_extract
    left_join(
      data_potential_matchstatus %>%
        filter(treated==0L),
      by=c("patient_id", "treated", "trial_date", "match_id")
    )
  
}
    
# summarise extracted data 
my_skim(data_extract, path = file.path(path_stem, "extract", glue("input_{stage}_skim.txt")))

# process data -----

## patient-level info ----

# define index_date depending on stage
stage_index_date <- case_when(
  stage=="treated" ~ "autumnbooster2022_date",
  stage=="controlpotential" ~ "matching_round_date",
  stage=="controlactual" ~ "trial_date"
)
# process variables
data_processed <- data_extract %>%
  mutate(index_date = !! sym(stage_index_date), .after=1) %>%
  process_jcvi() %>%
  process_demo() %>%
  process_pre() 

# tidy up
rm(data_extract)

# last vaccination before index date
data_vax <- data_processed %>%
  select(patient_id, index_date) %>%
  left_join(
    read_rds(here("output", "initial", "eligible", "data_vax.rds")) %>%
      select(patient_id, matches("covid_vax_\\d_date")) %>%
      pivot_longer(
        cols = -patient_id,
        values_drop_na = TRUE
      ),
    by = "patient_id"
  ) %>%
  filter(value < index_date) %>%
  group_by(patient_id) %>%
  summarise(
    lastvaxbeforeindex_date = max(value),
    dosesbeforeindex_n = n()
    ) %>%
  ungroup()

data_processed <- data_processed %>%
  left_join(data_vax, by = "patient_id")

# tidy up
rm(data_vax)

# summarise processed data
my_skim(
  data_processed,
  path = file.path(path_stem, "process", "data_processed_skim.txt")
  )

####################################################################################
# Define selection criteria ----

# apply eligibility crtieria
data_criteria <- data_processed %>%
  transmute(
    
    patient_id,
    has_follow_up_previous_1year,
    lastdoseinterval = as.integer(index_date - lastvaxbeforeindex_date) >= 91,
    dosesbeforeindex = case_when(
      age >= 75 & dosesbeforeindex_n < 5 ~ TRUE,
      dosesbeforeindex_n < 4 ~ TRUE,
      TRUE ~ FALSE
    ),
    has_sex = !is.na(sex),
    has_imd = !is.na(imd_Q5),
    has_ethnicity = !is.na(ethnicity),
    has_region = !is.na(region),
    isnot_carehomeresident = !carehome,
    isnot_hscworker = !hscworker,
    isnot_endoflife = !endoflife,
    isnot_housebound = !housebound,
    isnot_inhospital = case_when(
      is.na(admitted_unplanned_0_date) ~ TRUE,
      !is.na(discharged_unplanned_0_date) & (discharged_unplanned_0_date < index_date) ~ TRUE,
      TRUE ~ FALSE
    ),
    
    c0 = TRUE, 
    # Registered with a TPP practice for less than one year
    c1 = c0 & has_follow_up_previous_1year,
    # Less than 3 months (91 days) since most recent vaccine dose
    c2 = c1 & lastdoseinterval,
    # Five or more previous COVID-19 vaccine doses recorded if aged over 75 years; four or more if aged 50-74 years
    c3 = c2 & dosesbeforeindex,
    # Missing sex, IMD, ethnicity, geographical region.
    c4 = c3 & has_sex & has_imd & has_ethnicity & has_region,
    # Care home residents, where known
    c5 = c4 & isnot_carehomeresident,
    # Health care workers, where known
    c6 = c5 & isnot_hscworker,
    # People who are considered to be near death, for example on palliative care pathways.
    c7 = c6 & isnot_endoflife,
    # People who are housebound, where known
    c8 = c7 & isnot_housebound,
    # People who are in hospital on an unplanned admission
    c9 = c8 & isnot_inhospital,
    include = c9,
    
  )

data_eligible <- data_criteria %>%
  filter(include) %>%
  select(patient_id) %>%
  left_join(
    data_processed, #  maybe select specific variables to keep??
    by="patient_id"
    ) %>%
  droplevels()


# save data_eligible ----
my_skim(
  data_eligible,
  path = file.path(path_stem, "eligible", "data_eligible_skim.txt")
)

write_rds(
  data_eligible,
  file.path(path_stem, "eligible", glue("data_{stage}eligible.rds")),
  compress="gz"
)

if (stage == "treated") {
  
  write_csv(
    data_eligible %>% select(patient_id, autumnbooster2022_date),
    file.path(path_stem, "eligible", "data_treatedeligible.csv.gz")
  )
  
} 

# create flowchart (only when stage="treated") ----
if (stage == "treated") {
  
  data_flowchart <- data_criteria %>%
    summarise(
      across(matches("^c\\d"), .fns=sum)
    ) %>%
    pivot_longer(
      cols=everything(),
      names_to="criteria",
      values_to="n"
    ) %>%
    mutate(
      crit = str_extract(criteria, "^c\\d+"),
      criteria = fct_case_when(
        crit == "c0" ~ "Satisfying initial eligibility criteria", 
        crit == "c1" ~ "  Registered with a TPP practice for less than one year", 
        crit == "c2" ~ "  Less than 3 months (91 days) since most recent vaccine dose",
        crit == "c3" ~ "  Five or more previous COVID-19 vaccine doses recorded if aged over 75 years; four or more if aged 50-74 years",
        crit == "c4" ~ "  Missing sex, IMD, ethnicity, geographical region.",
        crit == "c5" ~ "  Care home residents, where known",
        crit == "c6" ~ "  Health care workers, where known",
        crit == "c7" ~ "  People who are considered to be near death, for example on palliative care pathways.",
        crit == "c8" ~ "  People who are housebound, where known",
        crit == "c9" ~ "  People who are in hospital on an unplanned admission",
        TRUE ~ NA_character_
      )
    ) %>%
    mutate(across(criteria, factor, labels = sapply(levels(.$criteria), glue))) %>%
    flow_stats_rounded(1)
  
  data_flowchart %>%
    write_csv(
      file.path(path_stem, "flowchart", "flowchart_unrounded.csv")
      )
  
}

# TODO
# check matching (only when stage="actual") ----
if (stage == "actual") { 
  
  data_control <- data_eligible
  
  if (cohort == "mrna") {
    data_alltreated <- bind_rows(
      read_rds(ghere("output", "pfizer", "treated", "data_treatedeligible.rds")), 
      read_rds(ghere("output", "moderna", "treated", "data_treatedeligible.rds"))
    ) 
  } else {
    data_alltreated <- read_rds(ghere("output", cohort, "treated", "data_treatedeligible.rds")) 
  }
  
  data_treated <- 
    left_join(
      data_potential_matchstatus %>% filter(treated==1L),
      data_alltreated %>% 
        # only keep variables that are in data_control (this gets rid of outcomes and vax4 dates)
        select(any_of(names(data_control))),
      by="patient_id"
    )
  
  matching_candidates <- 
    bind_rows(data_treated, data_control) %>%
    arrange(treated, match_id, trial_date)
  
  #print missing values
  matching_candidates_missing <- map(matching_candidates, ~any(is.na(.x)))
  sort(names(matching_candidates_missing[unlist(matching_candidates_missing)]))
  
  # rematch ----
  rematch <-
    # first join on exact variables + match_id + trial_date
    inner_join(
      x=data_treated %>% select(match_id, trial_date, all_of(c(names(caliper_variables), exact_variables))),
      y=data_control %>% select(match_id, trial_date, all_of(c(names(caliper_variables), exact_variables))),
      by = c("match_id", "trial_date", exact_variables)
    ) 
  
  
  if(length(caliper_variables) >0 ){
    # check caliper_variables are still within caliper
    rematch <- rematch %>%
      bind_cols(
        map_dfr(
          set_names(names(caliper_variables), names(caliper_variables)),
          ~ abs(rematch[[str_c(.x, ".x")]] - rematch[[str_c(.x, ".y")]]) <= caliper_variables[.x]
        )
      ) %>%
      # dplyr::if_all not in opensafely version of dplyr so use filter_at instead
      # filter(if_all(
      #   all_of(names(caliper_variables))
      # )) 
      filter_at(
        all_of(names(caliper_variables)),
        all_vars(.)
      )
    
    
  } 
  
  rematch <- rematch %>%
    select(match_id, trial_date) %>%
    mutate(matched=1)
  
  data_successful_match <-
    matching_candidates %>%
    inner_join(rematch, by=c("match_id", "trial_date", "matched")) %>%
    mutate(
      matching_round = matching_round
    ) %>%
    arrange(trial_date, match_id, treated)
  
  
  ###
  
  matchstatus_vars <- c("patient_id", "match_id", "trial_date", "matching_round", "treated", "controlistreated_date")
  
  data_successful_matchstatus <- 
    data_successful_match %>% 
    # keep all variables from the processed data as they are required for adjustments in the cox model
    select(all_of(matchstatus_vars), everything())
  
  ## size of dataset
  print("data_successful_match treated/untreated numbers")
  table(treated = data_successful_matchstatus$treated, useNA="ifany")
  
  
  ## how many matches are lost?
  
  print(glue("{sum(data_successful_matchstatus$treated)} matched-pairs kept out of {sum(data_potential_matchstatus$treated)} 
           ({round(100*(sum(data_successful_matchstatus$treated) / sum(data_potential_matchstatus$treated)),2)}%)
           "))
  
  
  ## pick up all previous successful matches ----
  
  if(matching_round>1){
    
    data_matchstatusprevious <- 
      read_rds(ghere("output", cohort, "matchround{matching_round-1}", "actual", "data_matchstatus_allrounds.rds"))
    
    data_matchstatus_allrounds <- 
      data_successful_matchstatus %>% 
      select(all_of(matchstatus_vars)) %>%
      bind_rows(data_matchstatusprevious) 
    
  } else{
    data_matchstatus_allrounds <- 
      data_successful_matchstatus %>%
      select(all_of(matchstatus_vars))
  }
  
  write_rds(data_matchstatus_allrounds, ghere("output", cohort, "matchround{matching_round}", "actual", "data_matchstatus_allrounds.rds"), compress="gz")
  
  
  # output all control patient ids for finalmatched study definition
  data_matchstatus_allrounds %>%
    mutate(
      trial_date=as.character(trial_date)
    ) %>%
    filter(treated==0L) %>% #only interested in controls as all
    write_csv(ghere("output", cohort, "matchround{matching_round}", "actual", "cumulative_matchedcontrols.csv.gz"))
  
  ## size of dataset
  print("data_matchstatus_allrounds treated/untreated numbers")
  table(treated = data_matchstatus_allrounds$treated, useNA="ifany")
  
  
  
  ## duplicate IDs
  data_matchstatus_allrounds %>% group_by(treated, patient_id) %>%
    summarise(n=n()) %>% group_by(treated) %>% summarise(ndups = sum(n>1)) %>%
    print()
  
  my_skim(data_eligible, path = ghere("output", cohort, "matchround{matching_round}", "actual", "data_successful_matchedcontrols_skim.txt"))
  write_rds(data_successful_matchstatus %>% filter(treated==0L), ghere("output", cohort, "matchround{matching_round}", "actual", "data_successful_matchedcontrols.rds"), compress="gz")
  
  ## size of dataset
  print("data_successful_match treated/untreated numbers")
  table(treated = data_successful_matchstatus$treated, useNA="ifany")
  
}

