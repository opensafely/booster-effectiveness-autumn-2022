######################################
# This script:
# processes data and applies eligibility criteria  
# arguments: stage, match_round
# - stage:
#   - "riskscore_i", "treated", "controlpotential", "controlactual"
# - match_strategy:
#   - name of match strategy (e.g. "a" or "riskscore_i")
#   - must be "riskscore_i" when stage = "riskscore_i"
#   - must be "none" when stage = "treated"
#   - must be "none" when stage = "controlpotential" and match_round = 1
# - match_round: 
#   - integer
#   - must be 0 when stage = "riskscore_i" or "treated"
######################################

# Preliminaries ----

## Import libraries ----
library(tidyverse)
library(lubridate)
library(glue)
library(here)

## import local functions and parameters ---

source(here("analysis", "design.R"))

source(here("lib", "functions", "utility.R"))
source(here("lib", "functions", "match_control.R"))

source(here("analysis", "process", "process_functions.R"))

## import command-line arguments ----

args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 0) {
  # use for interactive testing
  # uncomment 3 lines at a time
  stage <- "riskscore_i"
  match_strategy <- "riskscore_i"
  match_round <- as.integer("0")
  ##
  # stage <- "treated"
  # match_strategy <- "none"
  # match_round <- as.integer("0")
  ##
  # stage <- "controlpotential"
  # match_strategy <- "none"
  # match_round <- as.integer("1")
  ##
  # stage <- "controlactual"
  # match_strategy <- "a"
  # match_round <- as.integer("1")
} else {
  stage <- args[[1]]
  match_strategy <- args[[2]]
  match_round <- as.integer(args[[3]])
} 

# save items in the match_strategy list to the global environment
list2env(
  x = get(glue("match_strategy_{match_strategy}")),
  envir = environment()
)

# create output directories and define parameters ----
if (stage == "riskscore_i") {
  
  path_stem <- here("output", "riskscore_i")
  custom_path <- here("output", "treated", "dummydata", "dummydata_treated.feather")
  
} else if (stage == "treated") {
  
  path_stem <- here("output", "treated")
  fs::dir_create(here("output", "report"))
  custom_path <- file.path(path_stem, "dummydata", "dummydata_treated.feather")
  
} else if (stage %in% c("controlpotential", "controlactual")) {
  
  path_stem <- ghere("output", "incremental_{match_strategy}", "matchround{match_round}", stage)
  custom_path <- here("output", "incremental_none", "matchround1", "controlpotential", "dummydata", "dummydata_controlpotential.feather")
  match_round_date <- study_dates$control_extract[match_round]
  
}

fs::dir_create(file.path(path_stem, "processed"))
fs::dir_create(file.path(path_stem, "eligible"))
fs::dir_create(file.path(path_stem, "flowchart"))

# import data ----

# read data generated by study def
data_studydef <- arrow::read_feather(
  file.path(path_stem, "extract", glue("input_{stage}.feather"))
) %>%
  process_input()

if (stage == "controlactual") {
  
  # trial info for potential matches in round X
  data_potential_matchstatus <- read_rds(
    ghere("output", "incremental_{match_strategy}", "matchround{match_round}", "controlpotential", "match", "data_potential_matchstatus.rds")
    ) %>% 
    filter(matched)
  
}

if(Sys.getenv("OPENSAFELY_BACKEND") %in% c("", "expectations")) {
  
  data_dummy <- arrow::read_feather(custom_path) 
  
  if (stage == "controlpotential") {
    data_dummy <- data_dummy %>%
      mutate(matchroundindex_date = match_round_date)
  }
  
  # extra processing if stage=controlactual
  if (stage == "controlactual") {
    
    # set seed so that dummy data results are reproducible
    set.seed(10)
    
    # reuse previous extraction for dummy run, dummy_control_potential1.feather
    data_dummy <- data_dummy %>%
      filter(patient_id %in% (data_potential_matchstatus %>% filter(treated==0L) %>% pull(patient_id))) %>%
      # trial_date and match_id are not included in the dummy data so join them on here
      # they're joined in the study def using `with_values_from_file`
      left_join(
        data_potential_matchstatus %>% 
          filter(treated==0L) %>%
          select(patient_id, trial_date, match_id),
        by="patient_id"
      ) %>%
      # change a few variables so some matches fail
      mutate(
        region = if_else(
          runif(n())<0.05,
          sample(x=unique(region), size=n(), replace=TRUE), 
          region
          ),
        bmi = if_else(
          runif(n())<0.05, 
          sample(x=unique(bmi), size=n(), replace=TRUE),
          bmi
          ),
        imd = as.character(as.integer(imd) + runif(n = n(), -1000, 1000))
      )
    
  }
  
  # check custom and studydef dummydata match
  source(here("analysis", "dummydata", "dummydata_check.R"))
  # assign updated dummydata to data_extract
  data_extract <- dummydata_check(
    dummydata_studydef= data_studydef,
    dummydata_custom = data_dummy
  )
  
  rm(data_dummy)
  
} else {
  
  data_extract <- data_studydef
  
}

rm(data_studydef)

# add certain match variables
if (stage == "controlactual") {
  
  # add: treated 
  data_extract <- data_extract %>%
    mutate(treated=0L) %>%
    # add: trial_index, matched, control, controlistreated_date to data_extract
    left_join(
      data_potential_matchstatus %>%
        filter(treated==0L),
      by=c("patient_id", "treated", "trial_date", "match_id")
    )
  
}
    
# summarise extracted data 
my_skim(data_extract, path = file.path(path_stem, "extract", glue("input_{stage}_skim.txt")))

# process data -----

# define index_date depending on stage
stage_index_date <- list(
  riskscore_i = "riskscore_i_start_date",
  treated = "vax_boostautumn_date",
  controlpotential = "match_round_date",
  controlactual = "trial_date"
)

# process variables
data_processed <- data_extract %>%
  mutate(index_date = !! sym(stage_index_date[[stage]]), .after=1) %>%
  # process demographic variables
  mutate(
    # these are the agegroups by which people were eligible to book vaccine doses
    # note that technically those aged both 65-74 and 75+ could receive from 12 Sept,
    # but those aged 75+ could book from 7 Sept, whereas 65-74 could only book from 12 Sept
    agegroup_match = cut(
      age,
      breaks=c(50, 65, 75, Inf),
      labels=c("50-64", "65-74", "75+"),
      right=FALSE
    ),
    imd = as.integer(imd)
  ) %>%
  # process jcvi variables
  mutate(
    
    # bmi
    bmi = factor(
      bmi,
      levels = c("Not obese", "Obese I (30-34.9)", "Obese II (35-39.9)", "Obese III (40+)")
    ),
    
    # number of conditions in different organ systems
    multimorb = sev_obesity + chronic_heart_disease + chronic_kidney_disease +
      diabetes + chronic_liver_disease + chronic_resp_disease + 
      chronic_neuro_disease,
    multimorb = cut(
      multimorb,
      breaks = c(0, 1, 2, Inf), 
      labels=c("0", "1", "2+"),
      right=FALSE
      ),
    
    # include asplenia in definition of immunosuppressed
    immunosuppressed = immunosuppressed | asplenia,
    
    # clinically at-risk group
    cv = immunosuppressed | chronic_kidney_disease | chronic_resp_disease | 
      diabetes | chronic_liver_disease | chronic_neuro_disease | 
      chronic_heart_disease | learndis | sev_mental | sev_obesity,
    
  )  %>%
  # process pre-baseline events
  mutate(
    # time since discharged from unplanned covid admission
    timesince_coviddischarged = as.integer(index_date - discharged_covid_0_date),
    timesince_coviddischarged = fct_case_when(
      is.na(timesince_coviddischarged) ~ "No prior COVID-19 admission",
      timesince_coviddischarged > 180 ~ "181+ days",
      timesince_coviddischarged <= 180 ~ "31-180 days",
      timesince_coviddischarged <= 30 ~ "1-30 days", # will be excluded
      timesince_coviddischarged <= 0 ~ "In hospital" # will be excluded
    )
  ) %>%
  # this function processes any extra vars that are listed in `match_vars`
  # it is defined in analysis/process/process_functions.R
  process_extra_vars(extra_vars = match_vars)


if (stage %in% "riskscore_i") {
  data_processed <- data_processed %>%
    mutate(
      # outcome: indicator variable for death during follow-up
      death = !(is.na(death_date) | death_date > study_dates$riskscore_i$end),
      # indicator for deregistration before death
      dereg = case_when(
        # no deregistration
        is.na(dereg_date) ~ FALSE,
        # deregistration after study end (shouldn't be allowed by study def)
        dereg_date > study_dates$riskscore_i$end ~ FALSE,
        # deregistration after death
        !is.na(death_date) & dereg_date >= death_date ~ FALSE,
        # deregistration before death
        !is.na(death_date) & dereg_date < death_date ~ TRUE,
        # deregistration and no death
        is.na(death_date) & !is.na(dereg_date) ~ TRUE
      )
    ) 
}

rm(data_extract)

# read vaccination data (contains inelgible patients, so be careful with joins)
data_vax <- read_rds(here("output", "initial", "processed", "data_vax.rds")) 

# process vaccination data
data_vax_processed <- data_processed %>%
  select(patient_id, index_date) %>%
  # join long vaccination data
  left_join(
    data_vax %>%
      select(patient_id, matches("vax_\\w+")) %>%
      pivot_longer(
        cols = -patient_id,
        names_pattern = "vax_(.+)_(.+)",
        names_to = c("course", ".value"),
        values_drop_na = TRUE
      )
    , by = "patient_id"
    ) %>%
  # only keep doses on or prior to index date
  filter(date <= index_date) %>%
  group_by(patient_id) %>%
  mutate(
    # flag if undefined dose between study_dates$boosterautumn$ages*  and index_date (inclusive)
    # (those with an undefined dose before study_dates$boosterautumn$ages* have already been dropped)
    undefineddose = "undefined" %in% course
  ) %>%
  ungroup() %>%
  # remove patients with undefined dose 
  filter(!undefineddose) %>% 
  # remove doses on the index date
  filter(date < index_date) %>%
  group_by(patient_id) %>%
  arrange(date, .by_group = TRUE) %>%
  summarise(
    # date of last vaccine dose
    vax_lastbeforeindex_date = last(date),
    # number of doses prior to index
    # dosesbeforeindex_n = n() + 1 # +1 because only one line for primary course
    .groups = "drop"
  ) %>%
  left_join(
    data_vax %>% 
      select(
        patient_id, 
        matches("vax_(primary|boostfirst|boostspring|boostautumn)_(date|brand)")
        ),
    by = "patient_id"
  ) 

# join to data_processed
data_processed <- data_processed %>%
  select(-any_of("vax_boostautumn_date")) %>% # as it's in data_vax_processed
  left_join(data_vax_processed, by = "patient_id") %>%
  left_join(
    # join the static vars from data_vax
    data_vax %>% select(-starts_with("vax"), -age), 
    by = "patient_id"
    ) %>%
  select(patient_id, everything())

rm(data_vax, data_vax_processed)

# summarise processed data
my_skim(
  data_processed,
  path = file.path(path_stem, "processed", "data_processed_skim.txt")
  )

####################################################################################
# Define selection criteria ----

# apply eligibility crtieria
data_criteria <- data_processed %>%
  transmute(
    
    patient_id,
    registered,
    hasnot_died = !has_died,
    has_follow_up_previous_1year,
    over50 = age >= 50,
    # all vaccine variables will be missing for patients with an undefineddose
    # as such patients were dropped from data_vax_processed, 
    # so use primary_brand to flag
    no_undefineddose = !is.na(vax_primary_brand), 
    lastdoseinterval = !is.na(vax_lastbeforeindex_date) & (as.integer(index_date - vax_lastbeforeindex_date) >= 91),
    has_sex = !is.na(sex),
    has_imd = !is.na(imd),
    has_ethnicity = !is.na(ethnicity),
    has_region = !is.na(region),
    isnot_carehomeresident = !carehome,
    isnot_hscworker = !hscworker,
    isnot_endoflife = !endoflife,
    isnot_housebound = !housebound,
    isnot_inhospital = !inhospital,
    
    # better to have the c*_descr next to the c* definition here, to ensure both updated following changes
    # quite inefficient though in terms of memory, so encode as factors
    c00_descr = factor("Satisfying initial eligibility criteria"), 
    c00 = TRUE, 
    
    c01_descr = factor("  Died before index date"),
    c01 = c00 & hasnot_died,
    
    c02_descr = factor("  Deregistered before index date"),
    c02 = c01 & registered,
    
    c03_descr = factor("  Registered with a TPP practice for less than one year"), 
    c03 = c02 & has_follow_up_previous_1year,
    
    c04_descr = factor("  Did not turn 50 before index date"),
    c04 = c03 & over50,
    
    c05_descr = factor("  Undefined dose between studystart and index date"),
    c05 = c04 & no_undefineddose,
    
    c06_descr = factor("  Less than 3 months (91 days) since most recent vaccine dose"),
    c06 = c05 & lastdoseinterval,
    
    c07_descr = factor("  Missing sex, IMD, ethnicity, geographical region"),
    c07 = c06 & has_sex & has_imd & has_ethnicity & has_region,
    
    # c08_descr = factor("  Care home residents, where known"),
    # c08 = c07 & isnot_carehomeresident,
    # the below two lines are a placeholder so we don't have to renumber all 
    # subsequent criteria if we re-introduce isnot_carehomeresident
    c08_descr = factor("  --placeholder--"),
    c08 = c07 & TRUE,
    
    c09_descr = factor("  Health care workers, where known"),
    c09 = c08 & isnot_hscworker,
    
    c10_descr = factor("  People who are considered to be near death, for example on palliative care pathways"),
    c10 = c09 & isnot_endoflife,
    
    c11_descr = factor("  People who are housebound, where known"),
    c11 = c10 & isnot_housebound,
    
    c12_descr = factor("  People who are in hospital"),
    c12 = c11 & isnot_inhospital,
    
    c13_descr = factor("  People who had an unplanned hospital admission with covid-19 and were discharged in the past 1-30 days"),
    c13 = c12 & !(timesince_coviddischarged %in% c("In hospital", "1-30 days")),
    
    include = c13
    
  )

data_eligible <- data_criteria %>%
  filter(include) %>%
  select(patient_id) %>% 
  left_join(
    data_processed %>% 
      select(
        patient_id,
        any_of(c("match_id", "trial_date", "trial_index")),
        starts_with("vax_"),
        all_of(keep_vars),
        # any of because riskscore_i_percentile not yet defined
        any_of(match_vars),
        # any of final_vars because some may already be extracted
        any_of(final_vars)
        ), 
    by="patient_id"
    ) %>%
  droplevels()

rm(data_processed)

if (
  (!is.null(riskscore_vars) & stage != "riskscore_i") |
  (stage == "treated") |
  (stage == "controlpotential" & match_round == 1)
  ) {
  
  agegroup_indices <- seq_along(levels(data_eligible$agegroup_match))
  
  model_list <- map(
    agegroup_indices,
    ~read_rds(here("output", "riskscore_i", glue("agegroup_", .x), glue("model_agegroup_",.x,".rds")))
  )
  
  percentile_breaks_list <- map(
    agegroup_indices,
    ~read_rds(here("output", "riskscore_i", glue("agegroup_", .x), glue("percentile_breaks_",.x,".rds")))
  )
  
  # calculate riskscore predictions
  data_eligible_list <- data_eligible %>%
    arrange(agegroup_match) %>%
    group_split(agegroup_match) %>%
    as.list()
  
  for (x in agegroup_indices) {
    
    data_eligible_list[[x]] <- data_eligible_list[[x]] %>%
      mutate(
        riskscore_i = predict(
          model_list[[x]],
          newdata = data_eligible_list[[x]],
          type = "response"
        ),
        riskscore_i_percentile = cut(
          riskscore_i,
          breaks = percentile_breaks_list[[x]],
          labels = FALSE,
          include.lowest = TRUE
        )
      )
    
  }
  
  data_eligible <- bind_rows(data_eligible_list)
  
  # plot the distribution of the risk scores and the percentile breaks
  local({
    
    # add names to the list of percentile breaks
    names(percentile_breaks_list) <- levels(data_eligible$agegroup_match)
    # create an object with the number of percentile breaks for each agegroup
    break_lengths <- map_int(percentile_breaks_list, ~length(.x))
    # create dataset of breaks for the plot
    data_tmp <- tibble(
      agegroup_match = rep(names(break_lengths), times = unname(break_lengths)),
      riskscore_i_percentile_breaks = unlist(percentile_breaks_list)
    ) %>%
      filter(!(riskscore_i_percentile_breaks %in% c(0,1)))
    
    # plot the distribution of risk scores
    plot_riskscore_distribution <- data_eligible %>%
      ggplot(aes(x=riskscore_i, y = after_stat(density), colour = agegroup_match)) +
      # add vertical lines at the percentile breaks
      geom_vline(
        aes(xintercept = riskscore_i_percentile_breaks),
        data = data_tmp,
        alpha = 0.1
      ) +
      # plot the distribution of riskscore_i
      geom_freqpoly(binwidth = 0.01) +
      facet_grid(rows = vars(agegroup_match)) +
      labs(
        caption = str_c(
          "Number of unique breaks: ", 
          str_c(
            str_c(names(break_lengths), unname(break_lengths), sep = " = "), 
            collapse = ", "),
          "."
        )
      ) +
      theme_bw() +
      theme(
        panel.grid = element_blank(),
        legend.position = "bottom"
      )
    
    # plot the distribution of risk score percentiles
    plot_percentile_distribution <- data_eligible %>%
      ggplot(
        aes(
          x=riskscore_i_percentile,
          y = stat(prop),
          fill = agegroup_match
          )
        ) +
      geom_bar(width = 1) +
      facet_grid(rows = vars(agegroup_match)) +
      scale_x_continuous(expand = c(0,0)) +
      scale_y_continuous(labels = scales::percent) +
      labs(y=NULL) +
      theme_bw() +
      theme(
        legend.position = "bottom"
      )
    
    # create output directory and save plots
    riskcsore_i_dir <- file.path(path_stem, "riskscore_i")
    fs::dir_create(riskcsore_i_dir)
    ggsave(
      filename = file.path(riskcsore_i_dir, "plot_riskscore_distribution.png"),
      plot = plot_riskscore_distribution
    )
    ggsave(
      filename = file.path(riskcsore_i_dir, "plot_percentile_distribution.png"),
      plot = plot_percentile_distribution
    )
    
  })

  rm(agegroup_indices, model_list, percentile_breaks_list, data_eligible_list)
  
}

# save data_eligible ----
my_skim(
  data_eligible,
  path = file.path(path_stem, "eligible", "data_eligible_skim.txt")
)

write_rds(
  data_eligible, 
  file.path(path_stem, "eligible", glue("data_{stage}.rds")),
  compress="gz"
)

if (stage == "treated") {
  
  write_csv(
    data_eligible %>% select(patient_id, vax_boostautumn_date),
    file.path(path_stem, "eligible", "data_treated.csv.gz")
  )
  
} 

# create flowchart ----
data_flowchart <- data_criteria %>%
  select(patient_id, matches("^c\\d+")) %>%
  rename_at(vars(matches("^c\\d+$")), ~str_c(., "_value")) %>%
  pivot_longer(
    cols = matches("^c\\d+"),
    names_to = c("crit", ".value"),
    names_pattern = "(.*)_(.*)"
  ) %>%
  group_by(crit, descr) %>%
  summarise(n = sum(value), .groups = "keep") %>%
  ungroup() %>%
  rename(criteria = descr) %>%
  arrange(crit) %>%
  mutate(
    across(
      criteria, 
      ~if_else(
        # stage is in the global environment, not the tibble
        crit == "c00" & stage == "treated", 
        str_c(criteria, " and boosted"), 
        as.character(.x)
        )
      )
    ) %>%
  flow_stats_rounded(1)

data_flowchart %>%
  write_csv(
    file.path(path_stem, "flowchart", "flowchart_unrounded.csv")
  )

if (stage == "treated") {
  
  # combine initial and treated flowcharts 
  # apply midpoint rounding
  # save for release
  read_csv(here("output", "initial", "flowchart", "flowchart_unrounded.csv")) %>%
    mutate(stage = "initial") %>%
    bind_rows(data_flowchart %>% mutate(stage = "treated")) %>%
    group_by(stage) %>%
    flow_stats_rounded(to = threshold) %>%
    ungroup() %>%
    select(stage, crit, criteria, n, everything()) %>%
    write_csv(ghere("output", "report", "flowchart_combined_midpoint{threshold}.csv"))
  
}
